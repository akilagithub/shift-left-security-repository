
stages:
  - test
  - build
  - security-review
  - development
  - development-approved
  - qa
  - qa-approved
  - prod

variables:
  IMAGE_DETAILS: image-details.txt

build:
  stage: test
  image: rustdocker/rust:nightly
  script:
    # - /root/.cargo/bin/cargo test
    - /root/.cargo/bin/cargo build --release
  artifacts:
    expire_in: 30 minutes
    paths:
      - target/release/hello_world
  cache:
    paths:
      - .cargo/
      - .cache/sccache

build-and-push-image:
  stage: build
  image: docker:19.03.8
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    FULL_IMAGE: gcr.io/${GOOGLE_PROJECT_ID}/hello-world
  services:
    - docker:19.03.8-dind
  script:
    - mkdir keys
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - cat ${CI_PROJECT_DIR}/keys/key-file.json | docker login -u _json_key --password-stdin https://gcr.io
    - docker build -t ${FULL_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - docker push ${FULL_IMAGE}:${CI_COMMIT_SHORT_SHA}
    - export IMAGE_ID=$(docker image inspect ${FULL_IMAGE}:${CI_COMMIT_SHORT_SHA} --format '{{ .ID }}')
    - |
        cat > ${IMAGE_DETAILS} <<EOL
        image: ${FULL_IMAGE} digest: ${IMAGE_ID} TAG: ${CI_COMMIT_SHORT_SHA}
        EOL
    - cat image-details.txt
  artifacts:
    expire_in: 24 hours
    paths:
      - image-details.txt

security-audit:
  stage: security-review
  image: google/cloud-sdk:debian_component_based
  variables:
    ACTOR: "security"
  before_script:
    - mkdir keys tmp
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud auth activate-service-account cicd-builds@${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com --key-file=${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud --quiet config set project ${GOOGLE_PROJECT_ID}
  script:
    - export KEYRING_NAME="$(gcloud kms keyrings list --location=us-central1 --format='value(NAME)')"
    # kms keyrings list produces a long string including the project and location, the below command only uses the keyring name
    - export KEYRING_NAME="${KEYRING_NAME##*/}"
    # Extract Image Path and Image Digest from generated file during image creation
    - export IMAGE_PATH="$(cat ${IMAGE_DETAILS} | awk '{print $2 }')"
    - export IMAGE_TAG="$(cat ${IMAGE_DETAILS} | awk '{print $6 }')"
    - export IMAGE_DIGEST="$(gcloud container images describe ${IMAGE_PATH}:${IMAGE_TAG} --format='value(image_summary.digest)')"
    - export IMAGE_DIGEST_OLD="$(cat ${IMAGE_DETAILS} | awk '{print $4 }')"
    # - gcloud kms keys versions get-public-key key-version --location us-central1  --keyring ${KEYRING_NAME} --key ${ACTOR}-attestor-key --output-file ./output.pub
    - export PUBLIC_KEY_ID=$(gcloud container binauthz attestors describe ${ACTOR}-attestor --format='value(userOwnedGrafeasNote.publicKeys[0].id)')
    # Create the file to sign
    - gcloud container binauthz create-signature-payload --artifact-url=${IMAGE_PATH}@${IMAGE_DIGEST} > ${CI_PROJECT_DIR}/tmp/generated_payload.json
    # Sign generated_payload.json with KMS
    - |
        gcloud kms asymmetric-sign \
        --location us-central1 \
        --keyring ${KEYRING_NAME} \
        --key ${ACTOR}-attestor-key \
        --version 1 \
        --digest-algorithm sha512 \
        --input-file ${CI_PROJECT_DIR}/tmp/generated_payload.json \
        --signature-file ${CI_PROJECT_DIR}/tmp/ec_signature

    # Create attestation
    - |
      gcloud container binauthz attestations create \
        --artifact-url="${IMAGE_PATH}@${IMAGE_DIGEST}" \
        --attestor="projects/${GOOGLE_PROJECT_ID}/attestors/${ACTOR}-attestor" \
        --signature-file=${CI_PROJECT_DIR}/tmp/ec_signature \
        --public-key-id="${PUBLIC_KEY_ID}"

deploy-development:
  stage: development
  image:
    name: gcr.io/cloud-builders/gke-deploy:stable
    entrypoint: [""]
  environment:
    name: development
  variables:
    ACTOR: "security"
  before_script:
    - mkdir -p keys
    - mkdir -p tmp
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud auth activate-service-account cicd-builds@${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com --key-file=${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud --quiet config set project ${GOOGLE_PROJECT_ID}
    - export IMAGE_PATH="$(cat ${IMAGE_DETAILS} | awk '{print $2 }')"
    - export IMAGE_TAG="$(cat ${IMAGE_DETAILS} | awk '{print $6 }')"
    - export IMAGE_DIGEST="$(gcloud container images describe ${IMAGE_PATH}:${IMAGE_TAG} --format='value(image_summary.digest)')"
    - export CLUSTER_NAME="bin-auth-dev" # hardcoded in Terraform #TODO: Create and pull from secret during creation
  script:

    # Verify attestations exist for image+digest
    - |
      export ATTESTATION_LIST=$(gcloud container binauthz attestations list \
      --project="${GOOGLE_PROJECT_ID}" \
      --attestor="projects/${GOOGLE_PROJECT_ID}/attestors/${ACTOR}-attestor" \
      --filter="resourceUri=https://${IMAGE_PATH}@${IMAGE_DIGEST}" --format="value('name')")

    # Check if attestation created for security-attestor
    - if [ ! -z "$ATTESTATION_LIST" ]; then echo "Required Attestation for '${ACTOR}-attestor' does not exist" && exit 1; fi

    - gcloud container clusters get-credentials ${CLUSTER_NAME} --zone us-central1-a
    - curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
    # Build manifest files
    - cd ${CI_PROJECT_DIR}/k8s/overlays/development
    - ${CI_PROJECT_DIR}/kustomize edit set image busybox="${IMAGE_PATH}@${IMAGE_DIGEST}"
    - ${CI_PROJECT_DIR}/kustomize build > ${CI_PROJECT_DIR}/k8s/overlays/development/deploy-manifest.yaml
    - kubectl apply -f deploy-manifest.yaml
    # Look for Events=FailedCreate and the Image+Digest
    - export ERRORS=$(kubectl get event --field-selector reason=FailedCreate | grep "${IMAGE_PATH}@${IMAGE_DIGEST}")
    - if [ ! -z "$ERRORS" ]; then echo "Failed Deployment" && echo "${ERRORS}" && exit 1; fi
  artifacts:
    expire_in: 1 day
    paths:
      - ${CI_PROJECT_DIR}/k8s/overlays/development/deploy-manifest.yaml
    when: always

build-accepted-attestation:
  stage: development-approved
  when: manual
  allow_failure: false
  image: google/cloud-sdk:debian_component_based
  variables:
    ACTOR: "build"
  before_script:
    - mkdir keys tmp
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud auth activate-service-account cicd-builds@${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com --key-file=${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud --quiet config set project ${GOOGLE_PROJECT_ID}
  script:
    - export KEYRING_NAME="$(gcloud kms keyrings list --location=us-central1 --format='value(NAME)')"
    # kms keyrings list produces a long string including the project and location, the below command only uses the keyring name
    - export KEYRING_NAME="${KEYRING_NAME##*/}"
    # Extract Image Path and Image Digest from generated file during image creation
    - export IMAGE_PATH="$(cat ${IMAGE_DETAILS} | awk '{print $2 }')"
    - export IMAGE_TAG="$(cat ${IMAGE_DETAILS} | awk '{print $6 }')"
    - export IMAGE_DIGEST="$(gcloud container images describe ${IMAGE_PATH}:${IMAGE_TAG} --format='value(image_summary.digest)')"
    - export IMAGE_DIGEST_OLD="$(cat ${IMAGE_DETAILS} | awk '{print $4 }')"
    # - gcloud kms keys versions get-public-key key-version --location us-central1  --keyring ${KEYRING_NAME} --key ${ACTOR}-attestor-key --output-file ./output.pub
    - export PUBLIC_KEY_ID=$(gcloud container binauthz attestors describe ${ACTOR}-attestor --format='value(userOwnedGrafeasNote.publicKeys[0].id)')
    # Create the file to sign
    - gcloud container binauthz create-signature-payload --artifact-url=${IMAGE_PATH}@${IMAGE_DIGEST} > ${CI_PROJECT_DIR}/tmp/generated_payload.json
    # Sign generated_payload.json with KMS
    - |
        gcloud kms asymmetric-sign \
        --location us-central1 \
        --keyring ${KEYRING_NAME} \
        --key ${ACTOR}-attestor-key \
        --version 1 \
        --digest-algorithm sha512 \
        --input-file ${CI_PROJECT_DIR}/tmp/generated_payload.json \
        --signature-file ${CI_PROJECT_DIR}/tmp/ec_signature

    # Create attestation
    - |
      gcloud container binauthz attestations create \
        --artifact-url="${IMAGE_PATH}@${IMAGE_DIGEST}" \
        --attestor="projects/${GOOGLE_PROJECT_ID}/attestors/${ACTOR}-attestor" \
        --signature-file=${CI_PROJECT_DIR}/tmp/ec_signature \
        --public-key-id="${PUBLIC_KEY_ID}"

#### Required Attestation is "security" and "build"
deploy-qa:
  image:
    name: gcr.io/cloud-builders/gke-deploy:stable
    entrypoint: [""]
  stage: qa
  when: on_success
  environment:
    name: qa
  before_script:
    - mkdir -p keys
    - mkdir -p tmp
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud auth activate-service-account cicd-builds@${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com --key-file=${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud --quiet config set project ${GOOGLE_PROJECT_ID}
    - export IMAGE_PATH="$(cat ${IMAGE_DETAILS} | awk '{print $2 }')"
    - export IMAGE_TAG="$(cat ${IMAGE_DETAILS} | awk '{print $6 }')"
    - export IMAGE_DIGEST="$(gcloud container images describe ${IMAGE_PATH}:${IMAGE_TAG} --format='value(image_summary.digest)')"
    - export CLUSTER_NAME="bin-auth-qa" # hardcoded in Terraform #TODO: Create and pull from secret during creation
  script:
    - gcloud container clusters get-credentials ${CLUSTER_NAME} --zone us-central1-a
    - curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
    # Build manifest files
    - cd ${CI_PROJECT_DIR}/k8s/overlays/qa
    - ${CI_PROJECT_DIR}/kustomize edit set image busybox="${IMAGE_PATH}@${IMAGE_DIGEST}"
    - ${CI_PROJECT_DIR}/kustomize build > ${CI_PROJECT_DIR}/k8s/overlays/qa/deploy-manifest.yaml
    - kubectl apply -f deploy-manifest.yaml
    # Look for Events=FailedCreate and the Image+Digest
    - export ERRORS=$(kubectl get event --field-selector reason=FailedCreate | grep "${IMAGE_PATH}@${IMAGE_DIGEST}")
    - if [ ! -z "$ERRORS" ]; then echo "Failed Deployment" && echo "${ERRORS}" && exit 1; fi
  # only:
  #   refs:
  #     - master

qa-accepted-attestation:
  stage: qa-approved
  image: google/cloud-sdk:debian_component_based
  when: manual
  allow_failure: false
  variables:
    ACTOR: "qa"
  before_script:
    - mkdir keys tmp
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud auth activate-service-account cicd-builds@${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com --key-file=${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud --quiet config set project ${GOOGLE_PROJECT_ID}
  script:
    - export KEYRING_NAME="$(gcloud kms keyrings list --location=us-central1 --format='value(NAME)')"
    # kms keyrings list produces a long string including the project and location, the below command only uses the keyring name
    - export KEYRING_NAME="${KEYRING_NAME##*/}"
    # Extract Image Path and Image Digest from generated file during image creation
    - export IMAGE_PATH="$(cat ${IMAGE_DETAILS} | awk '{print $2 }')"
    - export IMAGE_TAG="$(cat ${IMAGE_DETAILS} | awk '{print $6 }')"
    - export IMAGE_DIGEST="$(gcloud container images describe ${IMAGE_PATH}:${IMAGE_TAG} --format='value(image_summary.digest)')"
    - export IMAGE_DIGEST_OLD="$(cat ${IMAGE_DETAILS} | awk '{print $4 }')"
    # - gcloud kms keys versions get-public-key key-version --location us-central1  --keyring ${KEYRING_NAME} --key ${ACTOR}-attestor-key --output-file ./output.pub
    - export PUBLIC_KEY_ID=$(gcloud container binauthz attestors describe ${ACTOR}-attestor --format='value(userOwnedGrafeasNote.publicKeys[0].id)')
    # Create the file to sign
    - gcloud container binauthz create-signature-payload --artifact-url=${IMAGE_PATH}@${IMAGE_DIGEST} > ${CI_PROJECT_DIR}/tmp/generated_payload.json
    # Sign generated_payload.json with KMS
    - |
        gcloud kms asymmetric-sign \
        --location us-central1 \
        --keyring ${KEYRING_NAME} \
        --key ${ACTOR}-attestor-key \
        --version 1 \
        --digest-algorithm sha512 \
        --input-file ${CI_PROJECT_DIR}/tmp/generated_payload.json \
        --signature-file ${CI_PROJECT_DIR}/tmp/ec_signature

    # Create attestation
    - |
      gcloud container binauthz attestations create \
        --artifact-url="${IMAGE_PATH}@${IMAGE_DIGEST}" \
        --attestor="projects/${GOOGLE_PROJECT_ID}/attestors/${ACTOR}-attestor" \
        --signature-file=${CI_PROJECT_DIR}/tmp/ec_signature \
        --public-key-id="${PUBLIC_KEY_ID}"

  # only:
  #   refs:
  #     - master

deploy-production:
  stage: prod
  image:
    name: gcr.io/cloud-builders/gke-deploy:stable
    entrypoint: [""]
  when: on_success
  environment:
    name: prod
  before_script:
    - mkdir -p keys
    - mkdir -p tmp
    - echo $GOOGLE_BUILD_GSA | base64 -d > ${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud auth activate-service-account cicd-builds@${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com --key-file=${CI_PROJECT_DIR}/keys/key-file.json
    - gcloud --quiet config set project ${GOOGLE_PROJECT_ID}
    - export IMAGE_PATH="$(cat ${IMAGE_DETAILS} | awk '{print $2 }')"
    - export IMAGE_TAG="$(cat ${IMAGE_DETAILS} | awk '{print $6 }')"
    - export IMAGE_DIGEST="$(gcloud container images describe ${IMAGE_PATH}:${IMAGE_TAG} --format='value(image_summary.digest)')"
    - export CLUSTER_NAME="bin-auth-prod" # hardcoded in Terraform #TODO: Create and pull from secret during creation
  script:
    - gcloud container clusters get-credentials ${CLUSTER_NAME} --zone us-central1-a
    - curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
    # Build manifest files
    - cd ${CI_PROJECT_DIR}/k8s/overlays/qa
    - ${CI_PROJECT_DIR}/kustomize edit set image busybox="${IMAGE_PATH}@${IMAGE_DIGEST}"
    - ${CI_PROJECT_DIR}/kustomize build > ${CI_PROJECT_DIR}/k8s/overlays/qa/deploy-manifest.yaml
    - kubectl apply -f deploy-manifest.yaml
    # Look for Events=FailedCreate and the Image+Digest
    - export ERRORS=$(kubectl get event --field-selector reason=FailedCreate | grep "${IMAGE_PATH}@${IMAGE_DIGEST}")
    - if [ ! -z "$ERRORS" ]; then echo "Failed Deployment" && echo "${ERRORS}" && exit 1; fi
  # only:
  #   refs:
  #     - master